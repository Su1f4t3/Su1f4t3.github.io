<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script><meta name="description" content="记录"><meta property="og:type" content="article"><meta property="og:title" content="pwn前置知识"><meta property="og:url" content="http://example.com/2025/03/29/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/index.html"><meta property="og:site_name" content="Su1f4t3的博客"><meta property="og:description" content="记录"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github.com/Su1f4t3/MyPic/blob/main/img/flag.png?raw=true"><meta property="article:published_time" content="2025-03-29T01:41:10.000Z"><meta property="article:modified_time" content="2025-04-06T05:55:42.047Z"><meta property="article:author" content="Su1f4t3"><meta property="article:tag" content="学习"><meta property="article:tag" content="pwn"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://github.com/Su1f4t3/MyPic/blob/main/img/flag.png?raw=true"><link rel="canonical" href="http://example.com/2025/03/29/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/03/29/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","path":"2025/03/29/前置知识/","title":"pwn前置知识"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>pwn前置知识 | Su1f4t3的博客</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Su1f4t3的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#L3PbU"><span class="nav-number">1.</span> <span class="nav-text">汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#u4Mjm"><span class="nav-number">1.1.</span> <span class="nav-text">Compiling 编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zkvlL"><span class="nav-number">1.2.</span> <span class="nav-text">Registers 寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#szC5D"><span class="nav-number">1.3.</span> <span class="nav-text">Words 字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lyej3"><span class="nav-number">1.4.</span> <span class="nav-text">Stacks 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mm92Y"><span class="nav-number">1.5.</span> <span class="nav-text">flag 标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q5RvI"><span class="nav-number">1.6.</span> <span class="nav-text">Instructions 指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tjprm"><span class="nav-number">2.</span> <span class="nav-text">逆向汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pAIXt"><span class="nav-number">2.1.</span> <span class="nav-text">hello_world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AqlBE"><span class="nav-number">2.2.</span> <span class="nav-text">if_then</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uFTaI"><span class="nav-number">2.3.</span> <span class="nav-text">loop</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Qjloo"><span class="nav-number">3.</span> <span class="nav-text">GDB调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LQSgN"><span class="nav-number">3.1.</span> <span class="nav-text">GDB基本命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JogKi"><span class="nav-number">3.2.</span> <span class="nav-text">内存操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lVxjk"><span class="nav-number">3.3.</span> <span class="nav-text">Running</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XPKmy"><span class="nav-number">3.4.</span> <span class="nav-text">Breakpoints</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rakgb"><span class="nav-number">3.5.</span> <span class="nav-text">Viewing Things</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dEgM3"><span class="nav-number">3.6.</span> <span class="nav-text">Changing Values</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NBxUH"><span class="nav-number">4.</span> <span class="nav-text">编写脚本</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Su1f4t3" src="/images/%E5%A4%B4%E5%83%8F.jpg"><p class="site-author-name" itemprop="name">Su1f4t3</p><div class="site-description" itemprop="description">叼</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Su1f4t3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Su1f4t3" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:a2211518633@gmail.com" title="E-Mail → mailto:a2211518633@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://github.com/Su1f4t3" title="https:&#x2F;&#x2F;github.com&#x2F;Su1f4t3" rel="noopener" target="_blank">Github</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2025/03/29/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.jpg"><meta itemprop="name" content="Su1f4t3"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Su1f4t3的博客"><meta itemprop="description" content="叼"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="pwn前置知识 | Su1f4t3的博客"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">pwn前置知识</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-03-29 09:41:10" itemprop="dateCreated datePublished" datetime="2025-03-29T09:41:10+08:00">2025-03-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-04-06 13:55:42" itemprop="dateModified" datetime="2025-04-06T13:55:42+08:00">2025-04-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>记录</p><span id="more"></span><p>本篇文章内容来自：<a target="_blank" rel="noopener" href="https://github.com/guyinatuxedo/nightmare/tree/master">https://github.com/guyinatuxedo/nightmare/tree/master</a></p><h1 id="L3PbU">汇编</h1><h2 id="u4Mjm">Compiling 编译</h2>首先，什么是汇编代码？汇编代码是处理器在计算机上实际运行的代码。例如，以一些 C 代码为例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>该代码未运行。事实是该代码被编译成汇编代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000001139 &lt;main&gt;:</span><br><span class="line">    1139:       55                      push   %rbp</span><br><span class="line">    113a:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    113d:       48 8d 05 c0 0e 00 00    lea    0xec0(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1144:       48 89 c7                mov    %rax,%rdi</span><br><span class="line">    1147:       e8 e4 fe ff ff          call   1030 &lt;puts@plt&gt;</span><br><span class="line">    114c:       90                      nop</span><br><span class="line">    114d:       5d                      pop    %rbp</span><br><span class="line">    114e:       c3                      ret</span><br></pre></td></tr></table></figure><p>我们编写代码交给编译器，编译器会获取该代码并生成汇编代码，该汇编代码将完成 C 代码所要求的任何事情。汇编代码才是处理器上实际运行的代码。</p><p>汇编代码也有很多不同的架构。不同类型的处理器可以运行不同类型的汇编代码架构。我们在这里最常处理的是 64 位和 32 位 ELF（可执行和可链接格式）。我经常将这两种东西称为 x64 和 x86 。</p><h2 id="zkvlL">Registers 寄存器</h2>寄存器本质上是处理器可以存储内存的地方。可以将它们视为处理器可以存储信息的存储桶。以下是 x64 寄存器的列表及其常见用例。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rbp: 基址指针（Base Pointer），指向当前栈帧的底部</span><br><span class="line">rsp: 栈指针（Stack Pointer），指向当前栈帧的顶部</span><br><span class="line">rip: 指令指针（Instruction Pointer），指向待执行的下一条指令</span><br><span class="line"></span><br><span class="line">通用寄存器：</span><br><span class="line">这些寄存器可用于多种用途</span><br><span class="line">rax:</span><br><span class="line">rbx:</span><br><span class="line">rcx:</span><br><span class="line">rdx:</span><br><span class="line">rsi:</span><br><span class="line">rdi:</span><br><span class="line">r8:</span><br><span class="line">r9:</span><br><span class="line">r10:</span><br><span class="line">r11:</span><br><span class="line">r12:</span><br><span class="line">r13:</span><br><span class="line">r14:</span><br><span class="line">r15:</span><br></pre></td></tr></table></figure><p>在 x64 Linux 中，函数的参数通过寄存器传递。前几个参数通过这些寄存器传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rdi:    First Argument</span><br><span class="line">rsi:    Second Argument</span><br><span class="line">rdx:    Third Argument</span><br><span class="line">rcx:    Fourth Argument</span><br><span class="line">r8:     Fifth Argument</span><br><span class="line">r9:     Sixth Argument</span><br></pre></td></tr></table></figure><p>在 x86 elf 架构中，参数传递：</p><p>架构 前 6 个整数参数 前 8 个浮点参数 额外参数 返回值</p><p>x86-64 rdi, rsi, rdx, rcx, r8, r9 xmm0 ~ xmm7 栈（右→左） rax / xmm0</p><p>x86 (32-bit) 全部通过栈（右→左） 栈（右→左） 栈（右→左）	eax / st(0)（浮点）</p><p>寄存器有不同的大小。我们将要处理的典型大小是 8 字节、 4 字节、 2 字节和 1 。这些不同大小的原因是由于技术的进步，我们可以在寄存器中存储更多数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+---------------+---------------+------------+</span><br><span class="line">| 8 Byte Register | Lower 4 Bytes | Lower 2 Bytes | Lower Byte |</span><br><span class="line">+-----------------+---------------+---------------+------------+</span><br><span class="line">|   rbp           |     ebp       |     bp        |     bpl    |</span><br><span class="line">|   rsp           |     esp       |     sp        |     spl    |</span><br><span class="line">|   rip           |     eip       |               |            |</span><br><span class="line">|   rax           |     eax       |     ax        |     al     |</span><br><span class="line">|   rbx           |     ebx       |     bx        |     bl     |</span><br><span class="line">|   rcx           |     ecx       |     cx        |     cl     |</span><br><span class="line">|   rdx           |     edx       |     dx        |     dl     |</span><br><span class="line">|   rsi           |     esi       |     si        |     sil    |</span><br><span class="line">|   rdi           |     edi       |     di        |     dil    |</span><br><span class="line">|   r8            |     r8d       |     r8w       |     r8b    |</span><br><span class="line">|   r9            |     r9d       |     r9w       |     r9b    |</span><br><span class="line">|   r10           |     r10d      |     r10w      |     r10b   |</span><br><span class="line">|   r11           |     r11d      |     r11w      |     r11b   |</span><br><span class="line">|   r12           |     r12d      |     r12w      |     r12b   |</span><br><span class="line">|   r13           |     r13d      |     r13w      |     r13b   |</span><br><span class="line">|   r14           |     r14d      |     r14w      |     r14b   |</span><br><span class="line">|   r15           |     r15d      |     r15w      |     r15b   |</span><br><span class="line">+-----------------+---------------+---------------+------------+</span><br></pre></td></tr></table></figure><p>在 x64 中，有 rax 、 eax 、 ax 和 al 寄存器。rax 指向完整的 8 。eax 只是 rax 寄存器的低四个字节。ax 是 rax 寄存器的最后 2 字节。最后 al 寄存器是 rax 寄存器的最后一个字节。</p><h2 id="szC5D">Words 字</h2>一个字只是两个字节的数据。<p>1位=1比特；1字节=8位；1字=2字节；1字=16位。</p><h2 id="Lyej3">Stacks 栈</h2>栈，是最常见的内存区域之一，它是存储代码中的**局部变量**的地方。<p>例如，在此代码中，变量 x 存储在栈中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">{</span><br><span class="line">    int x = 5;</span><br><span class="line">    puts("hi");</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>具体来说，我们可以看到它存储在栈上的 rbp-0x4 处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000001135 &lt;main&gt;:</span><br><span class="line">    1135:       55                      push   rbp</span><br><span class="line">    1136:       48 89 e5                mov    rbp,rsp</span><br><span class="line">    1139:       48 83 ec 10             sub    rsp,0x10</span><br><span class="line">    113d:       c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5</span><br><span class="line">    1144:       48 8d 3d b9 0e 00 00    lea    rdi,[rip+0xeb9]        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    114b:       e8 e0 fe ff ff          call   1030 &lt;puts@plt&gt;</span><br><span class="line">    1150:       90                      nop</span><br><span class="line">    1151:       c9                      leave  </span><br><span class="line">    1152:       c3                      ret    </span><br><span class="line">    1153:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">    115a:       00 00 00</span><br><span class="line">    115d:       0f 1f 00                nop    DWORD PTR [rax]</span><br></pre></td></tr></table></figure><p>现在，栈上的值可以通过将它们推入栈或弹出栈来移动。这是从栈中添加或删除值的唯一方法（它是一种 LIFO 数据结构）。我们也可以引用栈上的值。</p><p>栈的确切边界由两个寄存器 rbp 和 rsp 记录。基指针 rbp 指向栈帧的底部。栈指针 rsp 指向栈帧的顶部。</p><h2 id="Mm92Y">flag 标志</h2>在不同位数的CPU架构下，标志寄存器（FLAGS/EFLAGS/RFLAGS）的名称和宽度会发生变化，但其核心标志位（如ZF、CF等）的功能保持一致。<p>EFLAGS 是一个 32 位寄存器，用作表示布尔值的位的集合，用于存储操作结果和处理器的状态。</p><p>以下是 32 个不同位的名称，其中，灰色框中的 0 和 1 是保留位，不应修改：</p><p><img src="https://github.com/Su1f4t3/MyPic/blob/main/img/flag.png?raw=true"></p><p>更多详细信息，如这些标志的不同用途请查看：<a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#General-Purpose_Registers_(GPR)_-_16-bit_naming_conventions">https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#General-Purpose_Registers_(GPR)_-_16-bit_naming_conventions</a></p><h2 id="q5RvI">Instructions 指令</h2><p><strong>mov</strong></p><p>mov 指令只是将数据从一个寄存器移动到另一个寄存器。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdx</span><br></pre></td></tr></table></figure><p>这只会将数据从 rdx 寄存器移动到 rax 寄存器。</p><p><strong>dereference</strong></p><p>如果看到 [] 这样的括号，它们用于解引用，这涉及指针。指针是指向特定内存地址的值（它是内存地址，像是快递单号）。解引用是通过指针访问其指向内存中实际数据的过程，即“根据地址取数据”。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdx] </span><br></pre></td></tr></table></figure><p>将寄存器 rdx 中存储的内存地址处的值，复制到 rax 寄存器。</p><ul><li>rdx 中存有一个内存地址（如 0x1000）。</li><li>[rdx] 表示解引用，即访问地址 0x1000 处的数据（如数字 42）。</li><li>最终 rax 寄存器中存入值 42，而 rdx 的值（地址 0x1000）不变。</li></ul><p>另一方面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [rax], rdx </span><br></pre></td></tr></table></figure><p>将 rdx 寄存器中的值，写入寄存器 rax 中存储的内存地址处的值。</p><ul><li>rax 中存有一个内存地址（如 0x2000）。</li><li>[rax] 表示解引用，即操作地址 0x2000 处的内存。</li><li>将 rdx 的值（如 123）存入地址 0x2000，而 rax 的值（地址 0x2000）不变。</li></ul><p>指针不变性：</p><ul><li>解引用操作（[]）仅操作指针指向的数据，不会改变指针本身的值。</li><li>例如，mov [rax], rdx 执行后，rax 仍指向原地址，但该地址处的数据被更新。</li></ul><p><strong>lea</strong></p><p>lea 指令计算第二个操作数的地址，并将该地址移动到第一个操作数中。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea rdi, [rbx+0x10]</span><br></pre></td></tr></table></figure><p>这会将地址 rbx+0x10 移动到 rdi 寄存器中。</p><p>对比 mov：</p><ul><li>若使用 mov rdi, [rbx+0x10]，会读取内存地址 0x1010 处的值到 rdi。</li><li>lea 仅计算地址，不涉及内存读写。</li></ul><p><strong>add</strong></p><p>这只是将两个值相加，并将总和存储在第一个参数中。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rax, rdx</span><br></pre></td></tr></table></figure><p>这将使 rax 等于 rax + rdx</p><p><strong>sub</strong></p><p>该值将从第一个操作数中减去第二个操作数，并将差值存储在第一个参数中。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 0x10</span><br></pre></td></tr></table></figure><p>行为：</p><ul><li>读取 rsp 寄存器的当前值（例如 0x7ffffff0）。</li><li>减去立即数 0x10（十六进制的 16）。</li><li>将结果（0x7fffffe0）存回 rsp 寄存器。</li></ul><p><strong>xor</strong></p><p>这将对给定的两个参数执行二元运算 xor，并将结果存储在第一个运算中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor rdx, rax</span><br></pre></td></tr></table></figure><p>行为：</p><ul><li>逐位比较 rdx 和 rax 的值。</li><li>按异或规则生成结果。</li><li>将结果存入 rdx（覆盖原值）。</li></ul><p><strong>push</strong></p><p>push 指令将使栈增加 8 字节（对于 x64 ，对于 x86 为 4 ），然后将寄存器的内容推送到新的栈空间。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push rax</span><br></pre></td></tr></table></figure><p>这会使栈增加 8 字节，并且 rax 寄存器的内容将位于栈的顶部。</p><p><strong>pop</strong></p><p>pop 指令会将顶部 8 字节（对于 x64 为 4 ，对于 x86 为 4 个字节）弹出栈并放入参数中。然后它会缩小栈。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rax</span><br></pre></td></tr></table></figure><p>栈顶部的 8 字节最终将位于 rax 寄存器中。</p><p><strong>jmp</strong></p><p>jmp 指令将跳转到某个指令地址。它用于重定向代码执行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 0x602010</span><br></pre></td></tr></table></figure><p>该指令将导致代码执行跳转到 0x602010 ，并执行那里的任何指令。</p><p><strong>call</strong></p><p>将下一条指令地址压入栈，再跳转执行。</p><p>两步操作：</p><ul><li>压入返回地址：将 call 下一条指令的地址（即 rip）压入栈。</li><li>跳转到目标地址：修改 rip 为指定的函数入口地址。</li></ul><p>等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rip</span><br><span class="line">jmp &lt;func&gt;</span><br></pre></td></tr></table></figure><p><strong>ret</strong></p><p>将保存的地址取出，跳转执行。</p><p>两步操作：</p><ol><li>弹出返回地址：从栈顶弹出之前保存的地址到 rip。</li><li>跳转执行：CPU 从该地址继续执行。</li></ol><p>等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><p><strong>cmp</strong></p><p>cmp 指令与 sub 指令类似。只不过它不将结果存储在第一个参数中。它检查结果是小于零、大于零还是等于零。它会根据值相应地设置标志。</p><p><strong>jnz / jz</strong></p><p>此 jump if not zero 和 jump if zero ( jnz/jz ) 指令与跳转指令非常相似。不同之处在于它们只会根据标志 Zero Flag 的状态执行跳转。对于 jz ，它只会在设置 Zero Flag 时跳转。对于 jnz ，情况正好相反。</p><h1 id="tjprm">逆向汇编</h1>这些是一些基本的汇编逆向问题，文件来自：<ul><li><a target="_blank" rel="noopener" href="https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/HelloWorld/hello_world">https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/HelloWorld/hello_world</a></li><li><a target="_blank" rel="noopener" href="https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then">https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then</a></li><li><a target="_blank" rel="noopener" href="https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/Loop/loop">https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/Loop/loop</a></li></ul><h2 id="pAIXt">hello_world</h2>首先我们看一下汇编代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    objdump -D hello_world -M intel | less</span><br></pre></td></tr></table></figure><p>通过搜索字符串 main 来找到主函数后，我们看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">080483fb &lt;main&gt;:</span><br><span class="line"> 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line"> 80483ff:       83 e4 f0                and    esp,0xfffffff0</span><br><span class="line"> 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line"> 8048405:       55                      push   ebp</span><br><span class="line"> 8048406:       89 e5                   mov    ebp,esp</span><br><span class="line"> 8048408:       51                      push   ecx</span><br><span class="line"> 8048409:       83 ec 04                sub    esp,0x4</span><br><span class="line"> 804840c:       83 ec 0c                sub    esp,0xc</span><br><span class="line"> 804840f:       68 b0 84 04 08          push   0x80484b0</span><br><span class="line"> 8048414:       e8 b7 fe ff ff          call   80482d0 &lt;puts@plt&gt;</span><br><span class="line"> 8048419:       83 c4 10                add    esp,0x10</span><br><span class="line"> 804841c:       b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 8048421:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line"> 8048424:       c9                      leave  </span><br><span class="line"> 8048425:       8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line"> 8048428:       c3                      ret    </span><br><span class="line"> 8048429:       66 90                   xchg   ax,ax</span><br><span class="line"> 804842b:       66 90                   xchg   ax,ax</span><br><span class="line"> 804842d:       66 90                   xchg   ax,ax</span><br><span class="line"> 804842f:       90                      nop</span><br></pre></td></tr></table></figure><p>查看代码，我们看到对 puts 函数调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   0x80484b0</span><br><span class="line">call   80482d0 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><p>浏览其余代码，我们确实没有看到太多有趣的东西。所以这段代码可能只是打印一个字符串。当我们运行二进制文件时，我们发现这是正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$    ./hello_world</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>使用 IDA 查看伪代码，发现其和推理结果一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello world!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="AqlBE">if_then</h2>首先我们看一下汇编代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    objdump -D if_then -M intel | less</span><br></pre></td></tr></table></figure><p>通过搜索字符串 main 来找到主函数后，我们看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">080483fb &lt;main&gt;:</span><br><span class="line"> 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line"> 80483ff:       83 e4 f0                and    esp,0xfffffff0</span><br><span class="line"> 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line"> 8048405:       55                      push   ebp</span><br><span class="line"> 8048406:       89 e5                   mov    ebp,esp</span><br><span class="line"> 8048408:       51                      push   ecx</span><br><span class="line"> 8048409:       83 ec 14                sub    esp,0x14</span><br><span class="line"> 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa</span><br><span class="line"> 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa</span><br><span class="line"> 8048417:       75 10                   jne    8048429 &lt;main+0x2e&gt;</span><br><span class="line"> 8048419:       83 ec 0c                sub    esp,0xc</span><br><span class="line"> 804841c:       68 c0 84 04 08          push   0x80484c0</span><br><span class="line"> 8048421:       e8 aa fe ff ff          call   80482d0 &lt;puts@plt&gt;</span><br><span class="line"> 8048426:       83 c4 10                add    esp,0x10</span><br><span class="line"> 8048429:       b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line"> 8048431:       c9                      leave  </span><br><span class="line"> 8048432:       8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line"> 8048435:       c3                      ret    </span><br><span class="line"> 8048436:       66 90                   xchg   ax,ax</span><br><span class="line"> 8048438:       66 90                   xchg   ax,ax</span><br><span class="line"> 804843a:       66 90                   xchg   ax,ax</span><br><span class="line"> 804843c:       66 90                   xchg   ax,ax</span><br><span class="line"> 804843e:       66 90                   xchg   ax,ax</span><br></pre></td></tr></table></figure><p>我们可以看到它将值 0xa 加载到 ebp-0xc 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    DWORD PTR [ebp-0xc],0xa</span><br></pre></td></tr></table></figure><p>紧接着，我们看到它运行了 cmp 指令来检查它是否相等。如果它们不相等，它将跳转到 main+0x2e 。由于它刚刚加载了值 0xa ，因此它不应该进行跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp    DWORD PTR [ebp-0xc],0xa</span><br><span class="line">jne    8048429 &lt;main+0x2e&gt;</span><br></pre></td></tr></table></figure><p>接下来它应该调用 puts：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub    esp,0xc</span><br><span class="line">push   0x80484c0</span><br><span class="line">call   80482d0 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><p>因此，查看此代码后，我们发现它应该进行 puts 调用。运行它时，我们会看到它执行了以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$    ./if_then</span><br><span class="line">x = ten</span><br></pre></td></tr></table></figure><p>使用 IDA 查看伪代码，发现其和推理结果一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"x = ten"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="uFTaI">loop</h2>首先我们看一下汇编代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    objdump -D loop -M intel | less</span><br></pre></td></tr></table></figure><p>通过搜索字符串 main 来找到主函数后，我们看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">080483fb &lt;main&gt;:</span><br><span class="line"> 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line"> 80483ff:       83 e4 f0                and    esp,0xfffffff0</span><br><span class="line"> 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line"> 8048405:       55                      push   ebp</span><br><span class="line"> 8048406:       89 e5                   mov    ebp,esp</span><br><span class="line"> 8048408:       51                      push   ecx</span><br><span class="line"> 8048409:       83 ec 14                sub    esp,0x14</span><br><span class="line"> 804840c:       c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0</span><br><span class="line"> 8048413:       eb 17                   jmp    804842c &lt;main+0x31&gt;</span><br><span class="line"> 8048415:       83 ec 08                sub    esp,0x8</span><br><span class="line"> 8048418:       ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line"> 804841b:       68 c0 84 04 08          push   0x80484c0</span><br><span class="line"> 8048420:       e8 ab fe ff ff          call   80482d0 &lt;printf@plt&gt;</span><br><span class="line"> 8048425:       83 c4 10                add    esp,0x10</span><br><span class="line"> 8048428:       83 45 f4 01             add    DWORD PTR [ebp-0xc],0x1</span><br><span class="line"> 804842c:       83 7d f4 13             cmp    DWORD PTR [ebp-0xc],0x13</span><br><span class="line"> 8048430:       7e e3                   jle    8048415 &lt;main+0x1a&gt;</span><br><span class="line"> 8048432:       b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 8048437:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line"> 804843a:       c9                      leave  </span><br><span class="line"> 804843b:       8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line"> 804843e:       c3                      ret    </span><br><span class="line"> 804843f:       90                      nop</span><br></pre></td></tr></table></figure><p>在这个函数中，我们可以看到它将位于 ebp-0xc 的栈变量初始化为 0 ，然后跳转到 0x804842c （ main+0x31 ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    DWORD PTR [ebp-0xc],0x0</span><br><span class="line">jmp    804842c &lt;main+0x31&gt;</span><br></pre></td></tr></table></figure><p>查看 0x804842c 处的指令，我们看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp    DWORD PTR [ebp-0xc],0x13</span><br><span class="line">jle    8048415 &lt;main+0x1a&gt;</span><br></pre></td></tr></table></figure><p>我们看到它将地址 ebp-0xc 处的数据与 0x13 进行比较，如果小于或等于，则它将跳转到 0x8048415 ( 0x80483fb + 0x1a )。</p><p>查看 0x804842c 处的指令，这引出了 printf 调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub    esp,0x8</span><br><span class="line">push   DWORD PTR [ebp-0xc]</span><br><span class="line">push   0x80484c0</span><br><span class="line">call   80482d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure><p>它看起来像是以某种格式字符串打印出 ebp-0xc 的内容。</p><p>之后我们可以看到它增加了 ebp-0xc 的值，然后再次执行 cmp ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">cmp    DWORD PTR [ebp-0xc],0x13</span><br></pre></td></tr></table></figure><p>总结一下， [ebp-0xc] 的初始值为 0 ，和 0x13 比较，如果小于或等于，就把值 printf 出来，然后加上 0x1 ，再和 0x13 比较，如此循环。</p><p>所以，我们可能正在看一个将运行 20 次并每次打印迭代计数器的 for 循环。看起来类似于以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">for (i = 0; i &lt; 20; i ++)</span><br><span class="line">{</span><br><span class="line">    printf("%d", i);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当我们运行二进制文件时，我们发现它是正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$    ./loop</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</span><br></pre></td></tr></table></figure><p>使用 IDA 查看伪代码，发现其和推理结果一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="Qjloo">GDB调试</h1>调试文件下载：[https://github.com/guyinatuxedo/nightmare/blob/master/modules/02-intro_tooling/gdb-gef/hello_world](https://github.com/guyinatuxedo/nightmare/blob/master/modules/02-intro_tooling/gdb-gef/hello_world)<p>首先，gdb 是一个调试器（特别是 gnu 调试器），gef 是一个强大的 gdb 增强工具，提供了许多有用的功能来辅助二进制分析和漏洞利用开发。</p><h2 id="LQSgN">GDB基本命令</h2><ul><li>start - 开始调试，停在 main 函数入口</li><li>run / r - 运行程序</li><li>continue / c - 继续执行</li><li>stepi / si - 单步步入（进入函数调用）</li><li>nexti / ni - 单步步过（不进入函数调用）</li><li>break / b - 设置断点</li><li>b *0x地址 - 在指定地址设置断点</li><li>b 函数名 - 在函数入口设置断点</li><li>info breakpoints - 查看断点信息</li><li>delete / d - 删除断点</li></ul><h2 id="JogKi">内存操作</h2><ul><li>x/ - 检查内存</li><li>x/x 0x地址 - 以十六进制显示内存</li><li>x/s 0x地址 - 以字符串显示内存</li><li>x/i 0x地址 - 以指令显示内存</li><li>search-pattern - 在内存中搜索模式</li><li>dereference - 递归解引用指针</li></ul><h2 id="lVxjk">Running</h2>要在 gdb 中运行二进制 hello_world ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gdb ./hello_world </span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</span><br><span class="line">and "show warranty" for details.</span><br><span class="line">This GDB was configured as "x86_64-linux-gnu".</span><br><span class="line">Type "show configuration" for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type "help".</span><br><span class="line">Type "apropos word" to search for commands related to "word"...</span><br><span class="line">GEF for linux ready, type `gef' to start, `gef config' to configure</span><br><span class="line">75 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6</span><br><span class="line">[*] 5 commands could not be loaded, run `gef missing` to know why.</span><br><span class="line">Reading symbols from ./hello_world...(no debugging symbols found)...done.</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/devey/nightmare/modules/02-intro_tooling/hello_world </span><br><span class="line">hello world!</span><br><span class="line">[Inferior 1 (process 9133) exited normally]</span><br></pre></td></tr></table></figure><p>为了进入调试器模式，我们可以<strong>设置断点</strong>。断点是程序中 GDB 知道停止执行的位置，以便检查栈的内容。最常用的断点是在主程序上，我们可以使用“break main”或“b main”来设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">gef➤  break main</span><br><span class="line">Breakpoint 1 at 0x8048409</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/devey/nightmare/modules/02-intro_tooling/hello_world </span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0x080483fb  →  &lt;main+0000&gt; lea ecx, [esp+0x4]</span><br><span class="line">$ebx   : 0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                     ]#"?)</span><br><span class="line">$ecx   : 0xffffcf10  →  0x00000001</span><br><span class="line">$edx   : 0xffffcf30  →  0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                                    ]#"?)</span><br><span class="line">$esp   : 0xffffcef4  →  0xffffcf10  →  0x00000001</span><br><span class="line">$ebp   : 0xffffcef8  →  0x00000000</span><br><span class="line">$esi   : 0x08048430  →  &lt;__libc_csu_init+0000&gt; push ebp</span><br><span class="line">$edi   : 0xf7ffcb60  →  0x00000000</span><br><span class="line">$eip   : 0x08048409  →  &lt;main+000e&gt; sub esp, 0x4</span><br><span class="line">$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 </span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffcef4│+0x0000: 0xffffcf10  →  0x00000001    ← $esp</span><br><span class="line">0xffffcef8│+0x0004: 0x00000000   ← $ebp</span><br><span class="line">0xffffcefc│+0x0008: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">0xffffcf00│+0x000c: 0x00000000</span><br><span class="line">0xffffcf04│+0x0010: 0x00000000</span><br><span class="line">0xffffcf08│+0x0014: 0xf7da4069  →  &lt;__new_exitfn+0009&gt; add ebx, 0x1f7dab</span><br><span class="line">0xffffcf0c│+0x0018: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">0xffffcf10│+0x001c: 0x00000001</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">    0x8048405 &lt;main+000a&gt;      push   ebp</span><br><span class="line">    0x8048406 &lt;main+000b&gt;      mov    ebp, esp</span><br><span class="line">    0x8048408 &lt;main+000d&gt;      push   ecx</span><br><span class="line">●→  0x8048409 &lt;main+000e&gt;      sub    esp, 0x4</span><br><span class="line">    0x804840c &lt;main+0011&gt;      sub    esp, 0xc</span><br><span class="line">    0x804840f &lt;main+0014&gt;      push   0x80484b0</span><br><span class="line">    0x8048414 &lt;main+0019&gt;      call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">    0x8048419 &lt;main+001e&gt;      add    esp, 0x10</span><br><span class="line">    0x804841c &lt;main+0021&gt;      mov    eax, 0x0</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "hello_world", stopped 0x8048409 in main (), reason: BREAKPOINT</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x8048409 → main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>现在，可以通过键入“nexti”或者“ni”来逐步执行该函数，直到程序结束。“nexti”将让我们逐条指令地执行程序，但不会逐步执行诸如 puts 之类的函数调用。</p><h2 id="XPKmy">Breakpoints</h2>让我们使用“disassemble”或“disass”来看一下主要函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483fb &lt;+0&gt;:     lea    ecx,[esp+0x4]</span><br><span class="line">   0x080483ff &lt;+4&gt;:     and    esp,0xfffffff0</span><br><span class="line">   0x08048402 &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048405 &lt;+10&gt;:    push   ebp</span><br><span class="line">   0x08048406 &lt;+11&gt;:    mov    ebp,esp</span><br><span class="line">   0x08048408 &lt;+13&gt;:    push   ecx</span><br><span class="line">=&gt; 0x08048409 &lt;+14&gt;:    sub    esp,0x4</span><br><span class="line">   0x0804840c &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804840f &lt;+20&gt;:    push   0x80484b0</span><br><span class="line">   0x08048414 &lt;+25&gt;:    call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">   0x08048419 &lt;+30&gt;:    add    esp,0x10</span><br><span class="line">   0x0804841c &lt;+33&gt;:    mov    eax,0x0</span><br><span class="line">   0x08048421 &lt;+38&gt;:    mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08048424 &lt;+41&gt;:    leave</span><br><span class="line">   0x08048425 &lt;+42&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x08048428 &lt;+45&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>假设我们想在 puts 调用时中断。我们可以为该指令设置断点。</p><p>像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *main+25</span><br><span class="line">Breakpoint 1 at 0x8048414</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x08048414</span><br><span class="line">Note: breakpoint 1 also set at pc 0x08048414</span><br><span class="line">Breakpoint 2 at 0x08048414</span><br></pre></td></tr></table></figure><p>当我们运行二进制文件并尝试执行该指令时，该过程将暂停并将我们带入调试器控制台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/devey/nightmare/modules/02-intro_tooling/hello_world </span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0x080483fb  →  &lt;main+0000&gt; lea ecx, [esp+0x4]</span><br><span class="line">$ebx   : 0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                     ]#"?)</span><br><span class="line">$ecx   : 0xffffcf10  →  0x00000001</span><br><span class="line">$edx   : 0xffffcf30  →  0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                                    ]#"?)</span><br><span class="line">$esp   : 0xffffcef4  →  0xffffcf10  →  0x00000001</span><br><span class="line">$ebp   : 0xffffcef8  →  0x00000000</span><br><span class="line">$esi   : 0x08048430  →  &lt;__libc_csu_init+0000&gt; push ebp</span><br><span class="line">$edi   : 0xf7ffcb60  →  0x00000000</span><br><span class="line">$eip   : 0x08048409  →  &lt;main+000e&gt; sub esp, 0x4</span><br><span class="line">$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 </span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffcef4│+0x0000: 0xffffcf10  →  0x00000001    ← $esp</span><br><span class="line">0xffffcef8│+0x0004: 0x00000000   ← $ebp</span><br><span class="line">0xffffcefc│+0x0008: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">0xffffcf00│+0x000c: 0x00000000</span><br><span class="line">0xffffcf04│+0x0010: 0x00000000</span><br><span class="line">0xffffcf08│+0x0014: 0xf7da4069  →  &lt;__new_exitfn+0009&gt; add ebx, 0x1f7dab</span><br><span class="line">0xffffcf0c│+0x0018: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">0xffffcf10│+0x001c: 0x00000001</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">    0x8048405 &lt;main+000a&gt;      push   ebp</span><br><span class="line">    0x8048406 &lt;main+000b&gt;      mov    ebp, esp</span><br><span class="line">    0x8048408 &lt;main+000d&gt;      push   ecx</span><br><span class="line">●→  0x8048409 &lt;main+000e&gt;      sub    esp, 0x4</span><br><span class="line">    0x804840c &lt;main+0011&gt;      sub    esp, 0xc</span><br><span class="line">    0x804840f &lt;main+0014&gt;      push   0x80484b0</span><br><span class="line">●   0x8048414 &lt;main+0019&gt;      call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">    0x8048419 &lt;main+001e&gt;      add    esp, 0x10</span><br><span class="line">    0x804841c &lt;main+0021&gt;      mov    eax, 0x0</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "hello_world", stopped 0x8048409 in main (), reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x8048409 → main()</span><br></pre></td></tr></table></figure><p>在调试器控制台中，我们可以实际使用调试器提供各种类型的分析，并更改二进制文件的内容。现在让我们继续查看断点。要显示所有断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">1       breakpoint     keep y   0x08048409 &lt;main+14&gt;</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x08048414 &lt;main+25&gt;</span><br><span class="line">3       breakpoint     keep y   0x08048414 &lt;main+25&gt;</span><br></pre></td></tr></table></figure><p>可以缩写为“info b”或“i b”。</p><p>删除断点 Num 2 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef➤  delete 2</span><br></pre></td></tr></table></figure><p>可以缩写为“del 2”或“d 2”。</p><p>我们还可以为 puts 类的函数设置断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *puts</span><br><span class="line">Breakpoint 1 at 0x80482d0</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/devey/nightmare/modules/02-intro_tooling/hello_world </span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0x080483fb  →  &lt;main+0000&gt; lea ecx, [esp+0x4]</span><br><span class="line">$ebx   : 0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                     ]#"?)</span><br><span class="line">$ecx   : 0xffffcf10  →  0x00000001</span><br><span class="line">$edx   : 0xffffcf30  →  0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                                    ]#"?)</span><br><span class="line">$esp   : 0xffffcedc  →  0x08048419  →  &lt;main+001e&gt; add esp, 0x10</span><br><span class="line">$ebp   : 0xffffcef8  →  0x00000000</span><br><span class="line">$esi   : 0x08048430  →  &lt;__libc_csu_init+0000&gt; push ebp</span><br><span class="line">$edi   : 0xf7ffcb60  →  0x00000000</span><br><span class="line">$eip   : 0xf7de2100  →  &lt;puts+0000&gt; push ebp</span><br><span class="line">$eflags: [zero carry PARITY ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 </span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffcedc│+0x0000: 0x08048419  →  &lt;main+001e&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffffcee0│+0x0004: 0x080484b0  →  "hello world!"</span><br><span class="line">0xffffcee4│+0x0008: 0x00000000</span><br><span class="line">0xffffcee8│+0x000c: 0x00000000</span><br><span class="line">0xffffceec│+0x0010: 0x00000000</span><br><span class="line">0xffffcef0│+0x0014: 0x00000000</span><br><span class="line">0xffffcef4│+0x0018: 0xffffcf10  →  0x00000001</span><br><span class="line">0xffffcef8│+0x001c: 0x00000000   ← $ebp</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">   0xf7de20f5 &lt;_IO_proc_close+0245&gt; jmp    0xf7de2035 &lt;_IO_new_proc_close+389&gt;</span><br><span class="line">   0xf7de20fa &lt;_IO_proc_close+024a&gt; call   0xf7e9dc20 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0xf7de20ff                  nop    </span><br><span class="line">●→ 0xf7de2100 &lt;puts+0000&gt;      push   ebp</span><br><span class="line">   0xf7de2101 &lt;puts+0001&gt;      mov    ebp, esp</span><br><span class="line">   0xf7de2103 &lt;puts+0003&gt;      push   edi</span><br><span class="line">   0xf7de2104 &lt;puts+0004&gt;      call   0xf7ee74b5 &lt;__x86.get_pc_thunk.di&gt;</span><br><span class="line">   0xf7de2109 &lt;puts+0009&gt;      add    edi, 0x1b9d0b</span><br><span class="line">   0xf7de210f &lt;puts+000f&gt;      push   esi</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "hello_world", stopped 0xf7de2100 in __GI__IO_puts (), reason: BREAKPOINT</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xf7de2100 → __GI__IO_puts(str=0x80484b0 "hello world!")</span><br><span class="line">[#1] 0x8048419 → main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><h2 id="rakgb">Viewing Things</h2>gdb 真正有用的一件事就是查看不同事物的值。一旦我们在查看进程时进入调试器，让我们查看 esp 寄存器的内容。为了实现这一点，我们将在 main 上中断，运行，然后推进3次，直到执行 push 后：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">gef➤  break main </span><br><span class="line">gef➤  run</span><br><span class="line">gef➤  nexti 3</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0x080483fb  →  &lt;main+0000&gt; lea ecx, [esp+0x4]</span><br><span class="line">$ebx   : 0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                     ]#"?)</span><br><span class="line">$ecx   : 0xffffcf10  →  0x00000001</span><br><span class="line">$edx   : 0xffffcf30  →  0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                                    ]#"?)</span><br><span class="line">$esp   : 0xffffcee0  →  0x080484b0  →  "hello world!"</span><br><span class="line">$ebp   : 0xffffcef8  →  0x00000000</span><br><span class="line">$esi   : 0x08048430  →  &lt;__libc_csu_init+0000&gt; push ebp</span><br><span class="line">$edi   : 0xf7ffcb60  →  0x00000000</span><br><span class="line">$eip   : 0x08048414  →  0xfffeb7e8  →  0x00000000</span><br><span class="line">$eflags: [zero carry PARITY ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 </span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffcee0│+0x0000: 0x080484b0  →  "hello world!"        ← $esp</span><br><span class="line">0xffffcee4│+0x0004: 0x00000000</span><br><span class="line">0xffffcee8│+0x0008: 0x00000000</span><br><span class="line">0xffffceec│+0x000c: 0x00000000</span><br><span class="line">0xffffcef0│+0x0010: 0x00000000</span><br><span class="line">0xffffcef4│+0x0014: 0xffffcf10  →  0x00000001</span><br><span class="line">0xffffcef8│+0x0018: 0x00000000   ← $ebp</span><br><span class="line">0xffffcefc│+0x001c: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">●   0x8048409 &lt;main+000e&gt;      sub    esp, 0x4</span><br><span class="line">    0x804840c &lt;main+0011&gt;      sub    esp, 0xc</span><br><span class="line">    0x804840f &lt;main+0014&gt;      push   0x80484b0</span><br><span class="line"> →  0x8048414 &lt;main+0019&gt;      call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">   ↳   0x80482d0 &lt;puts@plt+0000&gt;  jmp    DWORD PTR ds:0x80496bc</span><br><span class="line">       0x80482d6 &lt;puts@plt+0006&gt;  push   0x0</span><br><span class="line">       0x80482db &lt;puts@plt+000b&gt;  jmp    0x80482c0</span><br><span class="line">       0x80482e0 &lt;__gmon_start__@plt+0000&gt; jmp    DWORD PTR ds:0x80496c0</span><br><span class="line">       0x80482e6 &lt;__gmon_start__@plt+0006&gt; push   0x8</span><br><span class="line">       0x80482eb &lt;__gmon_start__@plt+000b&gt; jmp    0x80482c0</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────</span><br><span class="line">puts@plt (</span><br><span class="line">   [sp + 0x0] = 0x080484b0 → "hello world!",</span><br><span class="line">   [sp + 0x4] = 0x00000000</span><br><span class="line">)</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "hello_world", stopped 0x8048414 in main (), reason: SINGLE STEP</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x8048414 → main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>我们可以看到寄存器 esp 保存的值是 0xffffcee0 ，这是一个指针。让我们看看它指向什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/a 0xffffcee0</span><br><span class="line">0xffffcee0:     0x80484b0</span><br><span class="line">gef➤  x/10c 0x80484b0</span><br><span class="line">0x80484b0:      0x68    0x65    0x6c    0x6c    0x6f    0x20    0x77    0x6f</span><br><span class="line">0x80484b8:      0x72    0x6c</span><br><span class="line">gef➤  x/s 0x80484b0</span><br><span class="line">0x80484b0:      "hello world!"</span><br></pre></td></tr></table></figure><p>我们可以看到它指向字符串 hello world! ，它将由 puts 打印（因为 puts 接受一个参数，即 char 指针）。</p><p>在 gdb 中，当我们使用 x 检查事物时，可以指定要将其检查为什么。可能的东西包括地址 x/a 、字符数 x/10c、 字符串 x/s 、qword x/g 或 dword x/w 。</p><p>让我们查看所有寄存器的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info registers</span><br><span class="line">eax            0x80483fb           0x80483fb</span><br><span class="line">ecx            0xffffcf10          0xffffcf10</span><br><span class="line">edx            0xffffcf30          0xffffcf30</span><br><span class="line">ebx            0xf7f9be14          0xf7f9be14</span><br><span class="line">esp            0xffffcee0          0xffffcee0</span><br><span class="line">ebp            0xffffcef8          0xffffcef8</span><br><span class="line">esi            0x8048430           0x8048430</span><br><span class="line">edi            0xf7ffcb60          0xf7ffcb60</span><br><span class="line">eip            0x8048414           0x8048414 &lt;main+25&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                0x23</span><br><span class="line">ss             0x2b                0x2b</span><br><span class="line">ds             0x2b                0x2b</span><br><span class="line">es             0x2b                0x2b</span><br><span class="line">fs             0x0                 0x0</span><br><span class="line">gs             0x63                0x63</span><br></pre></td></tr></table></figure><p>现在让我们查看栈框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info frame</span><br><span class="line">Stack level 0, frame at 0xffffcf10:</span><br><span class="line"> eip = 0x8048414 in main; saved eip = 0xf7d8ad43</span><br><span class="line"> Arglist at 0xffffcef8, args: </span><br><span class="line"> Locals at 0xffffcef8, Previous frame's sp is 0xffffcf10</span><br><span class="line"> Saved registers:</span><br><span class="line">  ebp at 0xffffcef8, eip at 0xffffcf0c</span><br></pre></td></tr></table></figure><p>现在让我们查看主要函数的反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483fb &lt;+0&gt;:     lea    ecx,[esp+0x4]</span><br><span class="line">   0x080483ff &lt;+4&gt;:     and    esp,0xfffffff0</span><br><span class="line">   0x08048402 &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048405 &lt;+10&gt;:    push   ebp</span><br><span class="line">   0x08048406 &lt;+11&gt;:    mov    ebp,esp</span><br><span class="line">   0x08048408 &lt;+13&gt;:    push   ecx</span><br><span class="line">   0x08048409 &lt;+14&gt;:    sub    esp,0x4</span><br><span class="line">   0x0804840c &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804840f &lt;+20&gt;:    push   0x80484b0</span><br><span class="line">=&gt; 0x08048414 &lt;+25&gt;:    call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">   0x08048419 &lt;+30&gt;:    add    esp,0x10</span><br><span class="line">   0x0804841c &lt;+33&gt;:    mov    eax,0x0</span><br><span class="line">   0x08048421 &lt;+38&gt;:    mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08048424 &lt;+41&gt;:    leave</span><br><span class="line">   0x08048425 &lt;+42&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x08048428 &lt;+45&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="dEgM3">Changing Values</h2>现在，我们正处于 put 的指令中。<p>假设我们想要更改要打印的内容。重要的是，在许多程序中，我们能否做到这一点取决于我们尝试替换的字符串的大小。如果用太大的内容覆盖它，则存在覆盖其他内存并破坏程序的风险。有很多解决方法，但从 bin-ex 的角度来看，这很少适用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">gef➤  set {char [12]} 0x080484b0 = "hello venus"</span><br><span class="line">gef➤  x/s 0x080484b0</span><br><span class="line">0x80484b0:	"hello venus"</span><br><span class="line">gef➤  nexti</span><br><span class="line">hello venus</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0xc       </span><br><span class="line">$ebx   : 0xf7f9be14  →  0x00235d0c ("</span><br><span class="line">                                     ]#"?)</span><br><span class="line">$ecx   : 0xf7f9d8a0  →  0x00000000</span><br><span class="line">$edx   : 0x0       </span><br><span class="line">$esp   : 0xffffcee0  →  0x080484b0  →  "hello venus"</span><br><span class="line">$ebp   : 0xffffcef8  →  0x00000000</span><br><span class="line">$esi   : 0x08048430  →  &lt;__libc_csu_init+0000&gt; push ebp</span><br><span class="line">$edi   : 0xf7ffcb60  →  0x00000000</span><br><span class="line">$eip   : 0x08048419  →  &lt;main+001e&gt; add esp, 0x10</span><br><span class="line">$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 </span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffcee0│+0x0000: 0x080484b0  →  "hello venus"         ← $esp</span><br><span class="line">0xffffcee4│+0x0004: 0x00000000</span><br><span class="line">0xffffcee8│+0x0008: 0x00000000</span><br><span class="line">0xffffceec│+0x000c: 0x00000000</span><br><span class="line">0xffffcef0│+0x0010: 0x00000000</span><br><span class="line">0xffffcef4│+0x0014: 0xffffcf10  →  0x00000001</span><br><span class="line">0xffffcef8│+0x0018: 0x00000000   ← $ebp</span><br><span class="line">0xffffcefc│+0x001c: 0xf7d8ad43  →  &lt;__libc_start_call_main+0073&gt; add esp, 0x10</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">    0x804840c &lt;main+0011&gt;      sub    esp, 0xc</span><br><span class="line">    0x804840f &lt;main+0014&gt;      push   0x80484b0</span><br><span class="line">    0x8048414 &lt;main+0019&gt;      call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line"> →  0x8048419 &lt;main+001e&gt;      add    esp, 0x10</span><br><span class="line">    0x804841c &lt;main+0021&gt;      mov    eax, 0x0</span><br><span class="line">    0x8048421 &lt;main+0026&gt;      mov    ecx, DWORD PTR [ebp-0x4]</span><br><span class="line">    0x8048424 &lt;main+0029&gt;      leave  </span><br><span class="line">    0x8048425 &lt;main+002a&gt;      lea    esp, [ecx-0x4]</span><br><span class="line">    0x8048428 &lt;main+002d&gt;      ret    </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "hello_world", stopped 0x8048419 in main (), reason: SINGLE STEP</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x8048419 → main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>现在假设我们想将存储在内存地址 0x08048451 的值更改为 0xfacade ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/g 0x08048451</span><br><span class="line">0x8048451 &lt;__libc_csu_init+33&gt;:	0xff08838d</span><br><span class="line">gef➤  set *0x08048451 = 0xfacade</span><br><span class="line">gef➤  x/g 0x08048451</span><br><span class="line">0x8048451 &lt;__libc_csu_init+33&gt;:	0xfacade</span><br></pre></td></tr></table></figure><p>假设我们想直接跳转到 0x08048451 这样的指令，并跳过其间的所有指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  j *0x08048451</span><br><span class="line">Continuing at 0x0x08048451.</span><br></pre></td></tr></table></figure><h1 id="NBxUH">编写脚本</h1>前提：pwntools<p>如果我们想将其导入到 python 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure><p>连接远程服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = remote("ip", 端口) # 如：target = remote("github.com", 9000)</span><br></pre></td></tr></table></figure><p>如果想运行目标二进制文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = process("./challenge")</span><br></pre></td></tr></table></figure><p>如果要将 gdb 调试器附加到某个进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(target)</span><br></pre></td></tr></table></figure><p>如果我们想将 gdb 调试器附加到某个进程，并且立即向 gdb 传递一个命令以在 main 处设置断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(target, gdbscript='b *main')</span><br></pre></td></tr></table></figure><p>如果我们想将变量 x 发送到 target （目标可以是进程，也可以是 pwntools 建立的远程连接）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.send(x)</span><br></pre></td></tr></table></figure><p>如果我们想要发送变量 x ，并在其末尾附加一个换行符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print target.recvline()</span><br></pre></td></tr></table></figure><p>如果我们想从 target 打印一行文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print target.recvline()</span><br></pre></td></tr></table></figure><p>如果我们想要打印从 target 到字符串 out 的所有文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print target.recvuntil("out")</span><br></pre></td></tr></table></figure><p>现在还有一件事，ELF 采用最低字节序存储数据，这意味着数据以最低有效字节优先的方式存储。在少数情况下，当我们扫描整数时，我们需要考虑到这一点。幸运的是，pwntools 会为我们处理这个问题。</p><p>将整数 y 打包为最小端 QWORD （常用于 x64 ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p64(x)</span><br></pre></td></tr></table></figure><p>将整数 y 打包为最小端 DWORD （常用于 x86 ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(x)</span><br></pre></td></tr></table></figure><p>它还可以解包我们获得的值。假设我们想解包一个最低端 QWORD 并获取其整数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64(x)</span><br></pre></td></tr></table></figure><p>要解包 DWORD：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32(x)</span><br></pre></td></tr></table></figure><p>最后，如果只是想直接与 target 交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.interactive()</span><br></pre></td></tr></table></figure><p>更多 pwntools 功能：<a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/">https://docs.pwntools.com/en/stable/</a></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a> <a href="/tags/pwn/" rel="tag"><i class="fa fa-tag"></i> pwn</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2025/03/28/hello-world/" rel="prev" title="Hexo"><i class="fa fa-angle-left"></i> Hexo</a></div><div class="post-nav-item"><a href="/2025/03/29/%E5%9F%BA%E6%9C%AC%20ROP/" rel="next" title="基本 ROP">基本 ROP <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Su1f4t3</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">18k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:06</span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>